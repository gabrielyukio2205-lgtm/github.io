<script>
const chatbox = document.getElementById('chatbox');
const userInput = document.getElementById('userInput');

// endpoint corrigido
const JADE_API_URL = 'https://madras1-jade-port.hf.space/run/predict';

// ajuste aqui se souber que o fn_index é outro
const FN_INDEX = 0;

// adiciona mensagem na UI
function appendMessage(sender, text) {
  const senderClass = sender === 'Você' ? 'user' : 'bot';
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${senderClass}`;
  messageDiv.innerHTML = `<div class="sender ${senderClass}">${sender}</div><div class="text">${text}</div>`;
  chatbox.appendChild(messageDiv);
  chatbox.scrollTop = chatbox.scrollHeight;
}

// função fetch com retries simples
async function postPredict(payload, retries = 3) {
  for (let i = 0; i <= retries; i++) {
    try {
      const resp = await fetch(JADE_API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      // se receber 503 (cold start), espera e tenta de novo
      if (resp.status === 503 && i < retries) {
        console.warn(`503 recebido — retry ${i+1}/${retries}`);
        await new Promise(r => setTimeout(r, 1000*(i+1)));
        continue;
      }

      const text = await resp.text(); // pega raw primeiro
      // tenta parsear JSON, se não for JSON devolve raw
      let json;
      try { json = JSON.parse(text); } catch(e) { json = text; }

      return { ok: resp.ok, status: resp.status, body: json };
    } catch (err) {
      console.error('Erro fetch (possível CORS ou rede):', err);
      if (i < retries) await new Promise(r => setTimeout(r, 1000*(i+1)));
      else throw err;
    }
  }
  throw new Error('Falha completa ao chamar predict');
}

// função principal de envio (usa postPredict)
async function sendMessage(message) {
  appendMessage('Você', message);
  userInput.value = '';

  // payload com fn_index (muito importante)
  const payload = {
    data: [
      message, // texto
      null,    // audio (se houver)
      null,    // imagem (se houver)
      []       // chat history — ajuste se quiser manter contexto
    ],
    fn_index: FN_INDEX
  };

  try {
    const resp = await postPredict(payload, 3);

    if (!resp.ok) {
      console.error('Resposta não OK:', resp.status, resp.body);
      appendMessage('Erro do Sistema', `Não foi possível conectar ao cérebro da J.A.D.E. (HTTP ${resp.status})`);
      return;
    }

    // log para você inspecionar a estrutura exata do retorno
    console.log('Resposta completa do Space:', resp.body);

    // tentativa resiliente de extrair a mensagem do bot
    let botMessage = null;

    // caso comum: result.data é um array e o primeiro item é o histórico
    if (Array.isArray(resp.body?.data) && resp.body.data.length > 0) {
      const first = resp.body.data[0];
      // se first for um array de pares [user, bot]
      if (Array.isArray(first) && first.length > 0) {
        const last = first[first.length - 1];
        if (Array.isArray(last) && last.length > 1) botMessage = last[1];
      }
      // se first for string (alguns apps retornam string direta)
      else if (typeof first === 'string') {
        botMessage = first;
      }
    }

    // fallbacks: algumas impls retornam text direto, ou body.output_text
    if (!botMessage) {
      if (typeof resp.body === 'string') botMessage = resp.body;
      else if (resp.body?.output?.text) botMessage = resp.body.output.text;
      else if (resp.body?.data && typeof resp.body.data === 'string') botMessage = resp.body.data;
    }

    if (!botMessage) {
      botMessage = '[Resposta em formato inesperado — veja console]';
      console.warn('Não consegui extrair a mensagem do bot automaticamente. Inspecione resp.body no console.');
    }

    appendMessage('J.A.D.E.', botMessage);

  } catch (error) {
    console.error('Erro ao chamar a API da J.A.D.E.:', error);
    appendMessage('Erro do Sistema', 'Não foi possível conectar ao cérebro da J.A.D.E. O backend pode estar offline ou bloqueando requisições.');
  }
}

// Enter para enviar
userInput.addEventListener('keydown', (event) => {
  if (event.key === 'Enter') {
    const message = userInput.value.trim();
    if (message) sendMessage(message);
  }
});
</script>
